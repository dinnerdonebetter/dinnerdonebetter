// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const acceptPrivacyPolicyForUser = `-- name: AcceptPrivacyPolicyForUser :exec
UPDATE users SET
	last_accepted_privacy_policy = NOW()
WHERE archived_at IS NULL
	AND id = $1
`

func (q *Queries) AcceptPrivacyPolicyForUser(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, acceptPrivacyPolicyForUser, id)
	return err
}

const acceptTermsOfServiceForUser = `-- name: AcceptTermsOfServiceForUser :exec
UPDATE users SET
	last_accepted_terms_of_service = NOW()
WHERE archived_at IS NULL
	AND id = $1
`

func (q *Queries) AcceptTermsOfServiceForUser(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, acceptTermsOfServiceForUser, id)
	return err
}

const archiveUser = `-- name: ArchiveUser :execrows
UPDATE users SET archived_at = NOW() WHERE archived_at IS NULL AND id = $1
`

func (q *Queries) ArchiveUser(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, archiveUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const archiveUserMemberships = `-- name: ArchiveUserMemberships :execrows
UPDATE household_user_memberships SET
	archived_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_user = $1
`

func (q *Queries) ArchiveUserMemberships(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, archiveUserMemberships, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users
(
	id,
	username,
	avatar_src,
	email_address,
	hashed_password,
	requires_password_change,
	two_factor_secret,
	two_factor_secret_verified_at,
	service_role,
	user_account_status,
	user_account_status_explanation,
	birthday,
	email_address_verification_token,
	first_name,
	last_name
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10,
	$11,
	$12,
	$13,
	$14,
	$15
)
`

type CreateUserParams struct {
	TwoFactorSecretVerifiedAt     sql.NullTime
	Birthday                      sql.NullTime
	TwoFactorSecret               string
	EmailAddress                  string
	HashedPassword                string
	ID                            string
	ServiceRole                   string
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	Username                      string
	FirstName                     string
	LastName                      string
	AvatarSrc                     sql.NullString
	EmailAddressVerificationToken sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) CreateUser(ctx context.Context, db DBTX, arg *CreateUserParams) error {
	_, err := db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.AvatarSrc,
		arg.EmailAddress,
		arg.HashedPassword,
		arg.RequiresPasswordChange,
		arg.TwoFactorSecret,
		arg.TwoFactorSecretVerifiedAt,
		arg.ServiceRole,
		arg.UserAccountStatus,
		arg.UserAccountStatusExplanation,
		arg.Birthday,
		arg.EmailAddressVerificationToken,
		arg.FirstName,
		arg.LastName,
	)
	return err
}

const deleteUser = `-- name: DeleteUser :execrows
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAdminUserByUsername = `-- name: GetAdminUserByUsername :one
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.service_role = 'service_admin'
	AND users.username = $1
	AND users.two_factor_secret_verified_at IS NOT NULL
`

type GetAdminUserByUsernameRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetAdminUserByUsername(ctx context.Context, db DBTX, username string) (*GetAdminUserByUsernameRow, error) {
	row := db.QueryRowContext(ctx, getAdminUserByUsername, username)
	var i GetAdminUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getEmailVerificationTokenByUserID = `-- name: GetEmailVerificationTokenByUserID :one
SELECT
	users.email_address_verification_token
FROM users
WHERE users.archived_at IS NULL
	AND users.email_address_verified_at IS NULL
	AND users.id = $1
`

func (q *Queries) GetEmailVerificationTokenByUserID(ctx context.Context, db DBTX, id string) (sql.NullString, error) {
	row := db.QueryRowContext(ctx, getEmailVerificationTokenByUserID, id)
	var email_address_verification_token sql.NullString
	err := row.Scan(&email_address_verification_token)
	return email_address_verification_token, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.email_address = $1
`

type GetUserByEmailRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserByEmail(ctx context.Context, db DBTX, emailAddress string) (*GetUserByEmailRow, error) {
	row := db.QueryRowContext(ctx, getUserByEmail, emailAddress)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserByEmailAddressVerificationToken = `-- name: GetUserByEmailAddressVerificationToken :one
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.email_address_verification_token = $1
`

type GetUserByEmailAddressVerificationTokenRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserByEmailAddressVerificationToken(ctx context.Context, db DBTX, emailAddressVerificationToken sql.NullString) (*GetUserByEmailAddressVerificationTokenRow, error) {
	row := db.QueryRowContext(ctx, getUserByEmailAddressVerificationToken, emailAddressVerificationToken)
	var i GetUserByEmailAddressVerificationTokenRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
`

type GetUserByIDRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id string) (*GetUserByIDRow, error) {
	row := db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.username = $1
`

type GetUserByUsernameRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserByUsername(ctx context.Context, db DBTX, username string) (*GetUserByUsernameRow, error) {
	row := db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserIDsNeedingIndexing = `-- name: GetUserIDsNeedingIndexing :many
SELECT users.id
FROM users
WHERE users.archived_at IS NULL
	AND users.last_indexed_at IS NULL
	OR users.last_indexed_at < NOW() - '24 hours'::INTERVAL
`

func (q *Queries) GetUserIDsNeedingIndexing(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, getUserIDsNeedingIndexing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithUnverifiedTwoFactor = `-- name: GetUserWithUnverifiedTwoFactor :one
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
	AND users.two_factor_secret_verified_at IS NULL
`

type GetUserWithUnverifiedTwoFactorRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserWithUnverifiedTwoFactor(ctx context.Context, db DBTX, id string) (*GetUserWithUnverifiedTwoFactorRow, error) {
	row := db.QueryRowContext(ctx, getUserWithUnverifiedTwoFactor, id)
	var i GetUserWithUnverifiedTwoFactorRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserWithVerifiedTwoFactor = `-- name: GetUserWithVerifiedTwoFactor :one
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
	AND users.two_factor_secret_verified_at IS NOT NULL
`

type GetUserWithVerifiedTwoFactorRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserWithVerifiedTwoFactor(ctx context.Context, db DBTX, id string) (*GetUserWithVerifiedTwoFactorRow, error) {
	row := db.QueryRowContext(ctx, getUserWithVerifiedTwoFactor, id)
	var i GetUserWithVerifiedTwoFactorRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUsers = `-- name: GetUsers :many
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at,
	(
		SELECT COUNT(users.id)
		FROM users
		WHERE users.archived_at IS NULL
			AND
			users.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
			AND users.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
			AND (
				users.last_updated_at IS NULL
				OR users.last_updated_at > COALESCE($3, (SELECT NOW() - '999 years'::INTERVAL))
			)
			AND (
				users.last_updated_at IS NULL
				OR users.last_updated_at < COALESCE($4, (SELECT NOW() + '999 years'::INTERVAL))
			)
			AND (NOT COALESCE($5, false)::boolean OR users.archived_at = NULL)
	) AS filtered_count,
	(
		SELECT COUNT(users.id)
		FROM users
		WHERE users.archived_at IS NULL
	) AS total_count
FROM users
WHERE users.archived_at IS NULL
	AND users.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
	AND users.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
	AND (
		users.last_updated_at IS NULL
		OR users.last_updated_at > COALESCE($4, (SELECT NOW() - '999 years'::INTERVAL))
	)
	AND (
		users.last_updated_at IS NULL
		OR users.last_updated_at < COALESCE($3, (SELECT NOW() + '999 years'::INTERVAL))
	)
			AND (NOT COALESCE($5, false)::boolean OR users.archived_at = NULL)
LIMIT $7
OFFSET $6
`

type GetUsersParams struct {
	CreatedAfter    sql.NullTime
	CreatedBefore   sql.NullTime
	UpdatedBefore   sql.NullTime
	UpdatedAfter    sql.NullTime
	IncludeArchived sql.NullBool
	QueryOffset     sql.NullInt32
	QueryLimit      sql.NullInt32
}

type GetUsersRow struct {
	CreatedAt                     time.Time
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	Birthday                      sql.NullTime
	LastUpdatedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastIndexedAt                 sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	ArchivedAt                    sql.NullTime
	Username                      string
	UserAccountStatusExplanation  string
	ServiceRole                   string
	EmailAddress                  string
	TwoFactorSecret               string
	UserAccountStatus             string
	LastName                      string
	FirstName                     string
	ID                            string
	HashedPassword                string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	FilteredCount                 int64
	TotalCount                    int64
	RequiresPasswordChange        bool
}

func (q *Queries) GetUsers(ctx context.Context, db DBTX, arg *GetUsersParams) ([]*GetUsersRow, error) {
	rows, err := db.QueryContext(ctx, getUsers,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.IncludeArchived,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUsersRow{}
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.AvatarSrc,
			&i.EmailAddress,
			&i.HashedPassword,
			&i.PasswordLastChangedAt,
			&i.RequiresPasswordChange,
			&i.TwoFactorSecret,
			&i.TwoFactorSecretVerifiedAt,
			&i.ServiceRole,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.Birthday,
			&i.EmailAddressVerificationToken,
			&i.EmailAddressVerifiedAt,
			&i.FirstName,
			&i.LastName,
			&i.LastAcceptedTermsOfService,
			&i.LastAcceptedPrivacyPolicy,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailAddressAsUnverified = `-- name: MarkEmailAddressAsUnverified :exec
UPDATE users SET
	email_address_verified_at = NULL,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND email_address_verified_at IS NOT NULL
	AND id = $1
`

func (q *Queries) MarkEmailAddressAsUnverified(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, markEmailAddressAsUnverified, id)
	return err
}

const markEmailAddressAsVerified = `-- name: MarkEmailAddressAsVerified :exec
UPDATE users SET
	email_address_verified_at = NOW(),
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND email_address_verified_at IS NULL
	AND id = $1
	AND email_address_verification_token = $2
`

type MarkEmailAddressAsVerifiedParams struct {
	ID                            string
	EmailAddressVerificationToken sql.NullString
}

func (q *Queries) MarkEmailAddressAsVerified(ctx context.Context, db DBTX, arg *MarkEmailAddressAsVerifiedParams) error {
	_, err := db.ExecContext(ctx, markEmailAddressAsVerified, arg.ID, arg.EmailAddressVerificationToken)
	return err
}

const markTwoFactorSecretAsUnverified = `-- name: MarkTwoFactorSecretAsUnverified :exec
UPDATE users SET
	two_factor_secret_verified_at = NULL,
	two_factor_secret = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type MarkTwoFactorSecretAsUnverifiedParams struct {
	TwoFactorSecret string
	ID              string
}

func (q *Queries) MarkTwoFactorSecretAsUnverified(ctx context.Context, db DBTX, arg *MarkTwoFactorSecretAsUnverifiedParams) error {
	_, err := db.ExecContext(ctx, markTwoFactorSecretAsUnverified, arg.TwoFactorSecret, arg.ID)
	return err
}

const markTwoFactorSecretAsVerified = `-- name: MarkTwoFactorSecretAsVerified :exec
UPDATE users SET
	two_factor_secret_verified_at = NOW(),
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $1
`

func (q *Queries) MarkTwoFactorSecretAsVerified(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, markTwoFactorSecretAsVerified, id)
	return err
}

const searchUsersByUsername = `-- name: SearchUsersByUsername :many
SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.username ILIKE '%' || $1::text || '%'
AND users.archived_at IS NULL
`

type SearchUsersByUsernameRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) SearchUsersByUsername(ctx context.Context, db DBTX, username string) ([]*SearchUsersByUsernameRow, error) {
	rows, err := db.QueryContext(ctx, searchUsersByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchUsersByUsernameRow{}
	for rows.Next() {
		var i SearchUsersByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.AvatarSrc,
			&i.EmailAddress,
			&i.HashedPassword,
			&i.PasswordLastChangedAt,
			&i.RequiresPasswordChange,
			&i.TwoFactorSecret,
			&i.TwoFactorSecretVerifiedAt,
			&i.ServiceRole,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.Birthday,
			&i.EmailAddressVerificationToken,
			&i.EmailAddressVerifiedAt,
			&i.FirstName,
			&i.LastName,
			&i.LastAcceptedTermsOfService,
			&i.LastAcceptedPrivacyPolicy,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserAvatarSrc = `-- name: UpdateUserAvatarSrc :execrows
UPDATE users SET
	avatar_src = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserAvatarSrcParams struct {
	ID        string
	AvatarSrc sql.NullString
}

func (q *Queries) UpdateUserAvatarSrc(ctx context.Context, db DBTX, arg *UpdateUserAvatarSrcParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserAvatarSrc, arg.AvatarSrc, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserDetails = `-- name: UpdateUserDetails :execrows
UPDATE users SET
	first_name = $1,
	last_name = $2,
	birthday = $3,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $4
`

type UpdateUserDetailsParams struct {
	FirstName string
	LastName  string
	Birthday  sql.NullTime
	ID        string
}

func (q *Queries) UpdateUserDetails(ctx context.Context, db DBTX, arg *UpdateUserDetailsParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserDetails,
		arg.FirstName,
		arg.LastName,
		arg.Birthday,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserEmailAddress = `-- name: UpdateUserEmailAddress :execrows
UPDATE users SET
	email_address = $1,
	email_address_verified_at = NULL,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserEmailAddressParams struct {
	EmailAddress string
	ID           string
}

func (q *Queries) UpdateUserEmailAddress(ctx context.Context, db DBTX, arg *UpdateUserEmailAddressParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserEmailAddress, arg.EmailAddress, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserLastIndexedAt = `-- name: UpdateUserLastIndexedAt :execrows
UPDATE users SET last_indexed_at = NOW() WHERE id = $1 AND archived_at IS NULL
`

func (q *Queries) UpdateUserLastIndexedAt(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserLastIndexedAt, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserPassword = `-- name: UpdateUserPassword :execrows
UPDATE users SET
	hashed_password = $1,
	password_last_changed_at = NOW(),
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserPasswordParams struct {
	HashedPassword string
	ID             string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, db DBTX, arg *UpdateUserPasswordParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserPassword, arg.HashedPassword, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserTwoFactorSecret = `-- name: UpdateUserTwoFactorSecret :execrows
UPDATE users SET
	two_factor_secret_verified_at = NULL,
	two_factor_secret = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserTwoFactorSecretParams struct {
	TwoFactorSecret string
	ID              string
}

func (q *Queries) UpdateUserTwoFactorSecret(ctx context.Context, db DBTX, arg *UpdateUserTwoFactorSecretParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserTwoFactorSecret, arg.TwoFactorSecret, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserUsername = `-- name: UpdateUserUsername :execrows
UPDATE users SET
	username = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserUsernameParams struct {
	Username string
	ID       string
}

func (q *Queries) UpdateUserUsername(ctx context.Context, db DBTX, arg *UpdateUserUsernameParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserUsername, arg.Username, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
