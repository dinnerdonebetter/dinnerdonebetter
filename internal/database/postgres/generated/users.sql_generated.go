// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const acceptPrivacyPolicyForUser = `-- name: AcceptPrivacyPolicyForUser :exec

UPDATE users SET
	last_accepted_privacy_policy = NOW()
WHERE archived_at IS NULL
	AND id = $1
`

func (q *Queries) AcceptPrivacyPolicyForUser(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, acceptPrivacyPolicyForUser, id)
	return err
}

const acceptTermsOfServiceForUser = `-- name: AcceptTermsOfServiceForUser :exec

UPDATE users SET
	last_accepted_terms_of_service = NOW()
WHERE archived_at IS NULL
	AND id = $1
`

func (q *Queries) AcceptTermsOfServiceForUser(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, acceptTermsOfServiceForUser, id)
	return err
}

const archiveUser = `-- name: ArchiveUser :execrows

UPDATE users SET archived_at = NOW() WHERE archived_at IS NULL AND id = $1
`

func (q *Queries) ArchiveUser(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, archiveUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const archiveUserMemberships = `-- name: ArchiveUserMemberships :execrows

UPDATE household_user_memberships SET
	archived_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_user = $1
`

func (q *Queries) ArchiveUserMemberships(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, archiveUserMemberships, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createUser = `-- name: CreateUser :exec

INSERT INTO users
(
	id,
	username,
	avatar_src,
	email_address,
	hashed_password,
	requires_password_change,
	two_factor_secret,
	two_factor_secret_verified_at,
	service_role,
	user_account_status,
	user_account_status_explanation,
	birthday,
	email_address_verification_token,
	first_name,
	last_name
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10,
	$11,
	$12,
	$13,
	$14,
	$15
)
`

type CreateUserParams struct {
	TwoFactorSecretVerifiedAt     sql.NullTime
	Birthday                      sql.NullTime
	TwoFactorSecret               string
	EmailAddress                  string
	HashedPassword                string
	ID                            string
	ServiceRole                   string
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	Username                      string
	FirstName                     string
	LastName                      string
	AvatarSrc                     sql.NullString
	EmailAddressVerificationToken sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) CreateUser(ctx context.Context, db DBTX, arg *CreateUserParams) error {
	_, err := db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.AvatarSrc,
		arg.EmailAddress,
		arg.HashedPassword,
		arg.RequiresPasswordChange,
		arg.TwoFactorSecret,
		arg.TwoFactorSecretVerifiedAt,
		arg.ServiceRole,
		arg.UserAccountStatus,
		arg.UserAccountStatusExplanation,
		arg.Birthday,
		arg.EmailAddressVerificationToken,
		arg.FirstName,
		arg.LastName,
	)
	return err
}

const getAdminUserByUsername = `-- name: GetAdminUserByUsername :one

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.service_role = 'service_admin'
	AND users.username = $1
	AND users.two_factor_secret_verified_at IS NOT NULL
`

type GetAdminUserByUsernameRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetAdminUserByUsername(ctx context.Context, db DBTX, username string) (*GetAdminUserByUsernameRow, error) {
	row := db.QueryRowContext(ctx, getAdminUserByUsername, username)
	var i GetAdminUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getEmailVerificationTokenByUserID = `-- name: GetEmailVerificationTokenByUserID :one

SELECT
	users.email_address_verification_token
FROM users
WHERE users.archived_at IS NULL
	AND users.email_address_verified_at IS NULL
	AND users.id = $1
`

func (q *Queries) GetEmailVerificationTokenByUserID(ctx context.Context, db DBTX, id string) (sql.NullString, error) {
	row := db.QueryRowContext(ctx, getEmailVerificationTokenByUserID, id)
	var email_address_verification_token sql.NullString
	err := row.Scan(&email_address_verification_token)
	return email_address_verification_token, err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.email_address = $1
`

type GetUserByEmailRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserByEmail(ctx context.Context, db DBTX, emailAddress string) (*GetUserByEmailRow, error) {
	row := db.QueryRowContext(ctx, getUserByEmail, emailAddress)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserByEmailAddressVerificationToken = `-- name: GetUserByEmailAddressVerificationToken :one

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.email_address_verification_token = $1
`

type GetUserByEmailAddressVerificationTokenRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserByEmailAddressVerificationToken(ctx context.Context, db DBTX, emailAddressVerificationToken sql.NullString) (*GetUserByEmailAddressVerificationTokenRow, error) {
	row := db.QueryRowContext(ctx, getUserByEmailAddressVerificationToken, emailAddressVerificationToken)
	var i GetUserByEmailAddressVerificationTokenRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
`

type GetUserByIDRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id string) (*GetUserByIDRow, error) {
	row := db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.username = $1
`

type GetUserByUsernameRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserByUsername(ctx context.Context, db DBTX, username string) (*GetUserByUsernameRow, error) {
	row := db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserIDsNeedingIndexing = `-- name: GetUserIDsNeedingIndexing :many

SELECT users.id
FROM users
WHERE users.archived_at IS NULL
	AND users.last_indexed_at IS NULL
	OR users.last_indexed_at < NOW() - '24 hours'::INTERVAL
`

func (q *Queries) GetUserIDsNeedingIndexing(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, getUserIDsNeedingIndexing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithUnverifiedTwoFactor = `-- name: GetUserWithUnverifiedTwoFactor :one

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
	AND users.two_factor_secret_verified_at IS NULL
`

type GetUserWithUnverifiedTwoFactorRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserWithUnverifiedTwoFactor(ctx context.Context, db DBTX, id string) (*GetUserWithUnverifiedTwoFactorRow, error) {
	row := db.QueryRowContext(ctx, getUserWithUnverifiedTwoFactor, id)
	var i GetUserWithUnverifiedTwoFactorRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUserWithVerifiedTwoFactor = `-- name: GetUserWithVerifiedTwoFactor :one

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
	AND users.two_factor_secret_verified_at IS NOT NULL
`

type GetUserWithVerifiedTwoFactorRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) GetUserWithVerifiedTwoFactor(ctx context.Context, db DBTX, id string) (*GetUserWithVerifiedTwoFactorRow, error) {
	row := db.QueryRowContext(ctx, getUserWithVerifiedTwoFactor, id)
	var i GetUserWithVerifiedTwoFactorRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.AvatarSrc,
		&i.EmailAddress,
		&i.HashedPassword,
		&i.PasswordLastChangedAt,
		&i.RequiresPasswordChange,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.EmailAddressVerificationToken,
		&i.EmailAddressVerifiedAt,
		&i.FirstName,
		&i.LastName,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getUsers = `-- name: GetUsers :many

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at,
	(
		SELECT COUNT(users.id)
		FROM users
		WHERE users.archived_at IS NULL
			AND users.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
			AND users.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
			AND (
				users.last_updated_at IS NULL
				OR users.last_updated_at > COALESCE($3, (SELECT NOW() - '999 years'::INTERVAL))
			)
			AND (
				users.last_updated_at IS NULL
				OR users.last_updated_at < COALESCE($4, (SELECT NOW() + '999 years'::INTERVAL))
			)
	) AS filtered_count,
	(
		SELECT COUNT(users.id)
		FROM users
		WHERE users.archived_at IS NULL
	) AS total_count
FROM users
WHERE users.archived_at IS NULL
	AND users.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
	AND users.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
	AND (
		users.last_updated_at IS NULL
		OR users.last_updated_at > COALESCE($4, (SELECT NOW() - '999 years'::INTERVAL))
	)
	AND (
		users.last_updated_at IS NULL
		OR users.last_updated_at < COALESCE($3, (SELECT NOW() + '999 years'::INTERVAL))
	)
LIMIT $6
OFFSET $5
`

type GetUsersParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetUsersRow struct {
	CreatedAt                     time.Time
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	Birthday                      sql.NullTime
	LastUpdatedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastIndexedAt                 sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	ArchivedAt                    sql.NullTime
	Username                      string
	UserAccountStatusExplanation  string
	ServiceRole                   string
	EmailAddress                  string
	TwoFactorSecret               string
	UserAccountStatus             string
	LastName                      string
	FirstName                     string
	ID                            string
	HashedPassword                string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	FilteredCount                 int64
	TotalCount                    int64
	RequiresPasswordChange        bool
}

func (q *Queries) GetUsers(ctx context.Context, db DBTX, arg *GetUsersParams) ([]*GetUsersRow, error) {
	rows, err := db.QueryContext(ctx, getUsers,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUsersRow{}
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.AvatarSrc,
			&i.EmailAddress,
			&i.HashedPassword,
			&i.PasswordLastChangedAt,
			&i.RequiresPasswordChange,
			&i.TwoFactorSecret,
			&i.TwoFactorSecretVerifiedAt,
			&i.ServiceRole,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.Birthday,
			&i.EmailAddressVerificationToken,
			&i.EmailAddressVerifiedAt,
			&i.FirstName,
			&i.LastName,
			&i.LastAcceptedTermsOfService,
			&i.LastAcceptedPrivacyPolicy,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailAddressAsUnverified = `-- name: MarkEmailAddressAsUnverified :exec

UPDATE users SET
	email_address_verified_at = NULL,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND email_address_verified_at IS NOT NULL
	AND id = $1
`

func (q *Queries) MarkEmailAddressAsUnverified(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, markEmailAddressAsUnverified, id)
	return err
}

const markEmailAddressAsVerified = `-- name: MarkEmailAddressAsVerified :exec

UPDATE users SET
	email_address_verified_at = NOW(),
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND email_address_verified_at IS NULL
	AND id = $1
	AND email_address_verification_token = $2
`

type MarkEmailAddressAsVerifiedParams struct {
	ID                            string
	EmailAddressVerificationToken sql.NullString
}

func (q *Queries) MarkEmailAddressAsVerified(ctx context.Context, db DBTX, arg *MarkEmailAddressAsVerifiedParams) error {
	_, err := db.ExecContext(ctx, markEmailAddressAsVerified, arg.ID, arg.EmailAddressVerificationToken)
	return err
}

const markTwoFactorSecretAsUnverified = `-- name: MarkTwoFactorSecretAsUnverified :exec

UPDATE users SET
	two_factor_secret_verified_at = NULL,
	two_factor_secret = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type MarkTwoFactorSecretAsUnverifiedParams struct {
	TwoFactorSecret string
	ID              string
}

func (q *Queries) MarkTwoFactorSecretAsUnverified(ctx context.Context, db DBTX, arg *MarkTwoFactorSecretAsUnverifiedParams) error {
	_, err := db.ExecContext(ctx, markTwoFactorSecretAsUnverified, arg.TwoFactorSecret, arg.ID)
	return err
}

const markTwoFactorSecretAsVerified = `-- name: MarkTwoFactorSecretAsVerified :exec

UPDATE users SET
	two_factor_secret_verified_at = NOW(),
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $1
`

func (q *Queries) MarkTwoFactorSecretAsVerified(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, markTwoFactorSecretAsVerified, id)
	return err
}

const searchUsersByUsername = `-- name: SearchUsersByUsername :many

SELECT
	users.id,
	users.username,
	users.avatar_src,
	users.email_address,
	users.hashed_password,
	users.password_last_changed_at,
	users.requires_password_change,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.email_address_verification_token,
	users.email_address_verified_at,
	users.first_name,
	users.last_name,
	users.last_accepted_terms_of_service,
	users.last_accepted_privacy_policy,
	users.last_indexed_at,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.username ILIKE '%' || $1::text || '%'
AND users.archived_at IS NULL
`

type SearchUsersByUsernameRow struct {
	CreatedAt                     time.Time
	Birthday                      sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	LastIndexedAt                 sql.NullTime
	PasswordLastChangedAt         sql.NullTime
	LastAcceptedPrivacyPolicy     sql.NullTime
	LastAcceptedTermsOfService    sql.NullTime
	TwoFactorSecretVerifiedAt     sql.NullTime
	EmailAddressVerifiedAt        sql.NullTime
	UserAccountStatus             string
	UserAccountStatusExplanation  string
	ID                            string
	ServiceRole                   string
	FirstName                     string
	LastName                      string
	TwoFactorSecret               string
	HashedPassword                string
	EmailAddress                  string
	Username                      string
	EmailAddressVerificationToken sql.NullString
	AvatarSrc                     sql.NullString
	RequiresPasswordChange        bool
}

func (q *Queries) SearchUsersByUsername(ctx context.Context, db DBTX, username string) ([]*SearchUsersByUsernameRow, error) {
	rows, err := db.QueryContext(ctx, searchUsersByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchUsersByUsernameRow{}
	for rows.Next() {
		var i SearchUsersByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.AvatarSrc,
			&i.EmailAddress,
			&i.HashedPassword,
			&i.PasswordLastChangedAt,
			&i.RequiresPasswordChange,
			&i.TwoFactorSecret,
			&i.TwoFactorSecretVerifiedAt,
			&i.ServiceRole,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.Birthday,
			&i.EmailAddressVerificationToken,
			&i.EmailAddressVerifiedAt,
			&i.FirstName,
			&i.LastName,
			&i.LastAcceptedTermsOfService,
			&i.LastAcceptedPrivacyPolicy,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserAvatarSrc = `-- name: UpdateUserAvatarSrc :execrows

UPDATE users SET
	avatar_src = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserAvatarSrcParams struct {
	ID        string
	AvatarSrc sql.NullString
}

func (q *Queries) UpdateUserAvatarSrc(ctx context.Context, db DBTX, arg *UpdateUserAvatarSrcParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserAvatarSrc, arg.AvatarSrc, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserDetails = `-- name: UpdateUserDetails :execrows

UPDATE users SET
	first_name = $1,
	last_name = $2,
	birthday = $3,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $4
`

type UpdateUserDetailsParams struct {
	FirstName string
	LastName  string
	Birthday  sql.NullTime
	ID        string
}

func (q *Queries) UpdateUserDetails(ctx context.Context, db DBTX, arg *UpdateUserDetailsParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserDetails,
		arg.FirstName,
		arg.LastName,
		arg.Birthday,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserEmailAddress = `-- name: UpdateUserEmailAddress :execrows

UPDATE users SET
	email_address = $1,
	email_address_verified_at = NULL,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserEmailAddressParams struct {
	EmailAddress string
	ID           string
}

func (q *Queries) UpdateUserEmailAddress(ctx context.Context, db DBTX, arg *UpdateUserEmailAddressParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserEmailAddress, arg.EmailAddress, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserLastIndexedAt = `-- name: UpdateUserLastIndexedAt :execrows

UPDATE users SET last_indexed_at = NOW() WHERE id = $1 AND archived_at IS NULL
`

func (q *Queries) UpdateUserLastIndexedAt(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserLastIndexedAt, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserPassword = `-- name: UpdateUserPassword :execrows

UPDATE users SET
	hashed_password = $1,
	password_last_changed_at = NOW(),
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserPasswordParams struct {
	HashedPassword string
	ID             string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, db DBTX, arg *UpdateUserPasswordParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserPassword, arg.HashedPassword, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserTwoFactorSecret = `-- name: UpdateUserTwoFactorSecret :execrows

UPDATE users SET
	two_factor_secret_verified_at = NULL,
	two_factor_secret = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserTwoFactorSecretParams struct {
	TwoFactorSecret string
	ID              string
}

func (q *Queries) UpdateUserTwoFactorSecret(ctx context.Context, db DBTX, arg *UpdateUserTwoFactorSecretParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserTwoFactorSecret, arg.TwoFactorSecret, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUserUsername = `-- name: UpdateUserUsername :execrows

UPDATE users SET
	username = $1,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $2
`

type UpdateUserUsernameParams struct {
	Username string
	ID       string
}

func (q *Queries) UpdateUserUsername(ctx context.Context, db DBTX, arg *UpdateUserUsernameParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateUserUsername, arg.Username, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
