// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: valid_vessels.sql

package generated

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const archiveValidVessel = `-- name: ArchiveValidVessel :execrows

UPDATE valid_vessels SET archived_at = NOW() WHERE archived_at IS NULL AND id = $1
`

func (q *Queries) ArchiveValidVessel(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, archiveValidVessel, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const checkValidVesselExistence = `-- name: CheckValidVesselExistence :one

SELECT EXISTS (
	SELECT valid_vessels.id
	FROM valid_vessels
	WHERE valid_vessels.archived_at IS NULL
		AND valid_vessels.id = $1
)
`

func (q *Queries) CheckValidVesselExistence(ctx context.Context, db DBTX, id string) (bool, error) {
	row := db.QueryRowContext(ctx, checkValidVesselExistence, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createValidVessel = `-- name: CreateValidVessel :exec

INSERT INTO valid_vessels (
	id,
	name,
	plural_name,
	description,
	icon_path,
	usable_for_storage,
	slug,
	display_in_summary_lists,
	include_in_generated_instructions,
	capacity,
	capacity_unit,
	width_in_millimeters,
	length_in_millimeters,
	height_in_millimeters,
	shape
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10,
	$11,
	$12,
	$13,
	$14,
	$15
)
`

type CreateValidVesselParams struct {
	Slug                           string
	ID                             string
	PluralName                     string
	Description                    string
	IconPath                       string
	Shape                          VesselShape
	Name                           string
	Capacity                       string
	CapacityUnit                   sql.NullString
	WidthInMillimeters             sql.NullString
	LengthInMillimeters            sql.NullString
	HeightInMillimeters            sql.NullString
	IncludeInGeneratedInstructions bool
	DisplayInSummaryLists          bool
	UsableForStorage               bool
}

func (q *Queries) CreateValidVessel(ctx context.Context, db DBTX, arg *CreateValidVesselParams) error {
	_, err := db.ExecContext(ctx, createValidVessel,
		arg.ID,
		arg.Name,
		arg.PluralName,
		arg.Description,
		arg.IconPath,
		arg.UsableForStorage,
		arg.Slug,
		arg.DisplayInSummaryLists,
		arg.IncludeInGeneratedInstructions,
		arg.Capacity,
		arg.CapacityUnit,
		arg.WidthInMillimeters,
		arg.LengthInMillimeters,
		arg.HeightInMillimeters,
		arg.Shape,
	)
	return err
}

const getRandomValidVessel = `-- name: GetRandomValidVessel :one

SELECT
	valid_vessels.id,
	valid_vessels.name,
	valid_vessels.plural_name,
	valid_vessels.description,
	valid_vessels.icon_path,
	valid_vessels.usable_for_storage,
	valid_vessels.slug,
	valid_vessels.display_in_summary_lists,
	valid_vessels.include_in_generated_instructions,
	valid_vessels.capacity,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.last_indexed_at as valid_measurement_unit_last_indexed_at,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	valid_vessels.width_in_millimeters,
	valid_vessels.length_in_millimeters,
	valid_vessels.height_in_millimeters,
	valid_vessels.shape,
	valid_vessels.last_indexed_at,
	valid_vessels.created_at,
	valid_vessels.last_updated_at,
	valid_vessels.archived_at
FROM valid_vessels
	JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
ORDER BY RANDOM() LIMIT 1
`

type GetRandomValidVesselRow struct {
	CreatedAt                         time.Time
	ValidMeasurementUnitCreatedAt     time.Time
	ValidMeasurementUnitArchivedAt    sql.NullTime
	ValidMeasurementUnitLastUpdatedAt sql.NullTime
	ValidMeasurementUnitLastIndexedAt sql.NullTime
	ArchivedAt                        sql.NullTime
	LastIndexedAt                     sql.NullTime
	LastUpdatedAt                     sql.NullTime
	ValidMeasurementUnitDescription   string
	Description                       string
	ValidMeasurementUnitID            string
	ValidMeasurementUnitName          string
	Name                              string
	PluralName                        string
	ValidMeasurementUnitIconPath      string
	ID                                string
	Slug                              string
	Shape                             VesselShape
	ValidMeasurementUnitSlug          string
	ValidMeasurementUnitPluralName    string
	IconPath                          string
	Capacity                          string
	HeightInMillimeters               sql.NullString
	WidthInMillimeters                sql.NullString
	LengthInMillimeters               sql.NullString
	ValidMeasurementUnitVolumetric    sql.NullBool
	IncludeInGeneratedInstructions    bool
	ValidMeasurementUnitImperial      bool
	ValidMeasurementUnitMetric        bool
	ValidMeasurementUnitUniversal     bool
	DisplayInSummaryLists             bool
	UsableForStorage                  bool
}

func (q *Queries) GetRandomValidVessel(ctx context.Context, db DBTX) (*GetRandomValidVesselRow, error) {
	row := db.QueryRowContext(ctx, getRandomValidVessel)
	var i GetRandomValidVesselRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Capacity,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitLastIndexedAt,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.WidthInMillimeters,
		&i.LengthInMillimeters,
		&i.HeightInMillimeters,
		&i.Shape,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidVessel = `-- name: GetValidVessel :one

SELECT
	valid_vessels.id,
	valid_vessels.name,
	valid_vessels.plural_name,
	valid_vessels.description,
	valid_vessels.icon_path,
	valid_vessels.usable_for_storage,
	valid_vessels.slug,
	valid_vessels.display_in_summary_lists,
	valid_vessels.include_in_generated_instructions,
	valid_vessels.capacity,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.last_indexed_at as valid_measurement_unit_last_indexed_at,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	valid_vessels.width_in_millimeters,
	valid_vessels.length_in_millimeters,
	valid_vessels.height_in_millimeters,
	valid_vessels.shape,
	valid_vessels.last_indexed_at,
	valid_vessels.created_at,
	valid_vessels.last_updated_at,
	valid_vessels.archived_at
FROM valid_vessels
	JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	AND valid_vessels.id = $1
`

type GetValidVesselRow struct {
	CreatedAt                         time.Time
	ValidMeasurementUnitCreatedAt     time.Time
	ValidMeasurementUnitArchivedAt    sql.NullTime
	ValidMeasurementUnitLastUpdatedAt sql.NullTime
	ValidMeasurementUnitLastIndexedAt sql.NullTime
	ArchivedAt                        sql.NullTime
	LastIndexedAt                     sql.NullTime
	LastUpdatedAt                     sql.NullTime
	ValidMeasurementUnitDescription   string
	Description                       string
	ValidMeasurementUnitID            string
	ValidMeasurementUnitName          string
	Name                              string
	PluralName                        string
	ValidMeasurementUnitIconPath      string
	ID                                string
	Slug                              string
	Shape                             VesselShape
	ValidMeasurementUnitSlug          string
	ValidMeasurementUnitPluralName    string
	IconPath                          string
	Capacity                          string
	HeightInMillimeters               sql.NullString
	WidthInMillimeters                sql.NullString
	LengthInMillimeters               sql.NullString
	ValidMeasurementUnitVolumetric    sql.NullBool
	IncludeInGeneratedInstructions    bool
	ValidMeasurementUnitImperial      bool
	ValidMeasurementUnitMetric        bool
	ValidMeasurementUnitUniversal     bool
	DisplayInSummaryLists             bool
	UsableForStorage                  bool
}

func (q *Queries) GetValidVessel(ctx context.Context, db DBTX, id string) (*GetValidVesselRow, error) {
	row := db.QueryRowContext(ctx, getValidVessel, id)
	var i GetValidVesselRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Capacity,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitLastIndexedAt,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.WidthInMillimeters,
		&i.LengthInMillimeters,
		&i.HeightInMillimeters,
		&i.Shape,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidVesselIDsNeedingIndexing = `-- name: GetValidVesselIDsNeedingIndexing :many

SELECT valid_vessels.id
FROM valid_vessels
WHERE valid_vessels.archived_at IS NULL
	AND (
	valid_vessels.last_indexed_at IS NULL
	OR valid_vessels.last_indexed_at < NOW() - '24 hours'::INTERVAL
)
`

func (q *Queries) GetValidVesselIDsNeedingIndexing(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, getValidVesselIDsNeedingIndexing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidVessels = `-- name: GetValidVessels :many

SELECT
	valid_vessels.id,
	valid_vessels.name,
	valid_vessels.plural_name,
	valid_vessels.description,
	valid_vessels.icon_path,
	valid_vessels.usable_for_storage,
	valid_vessels.slug,
	valid_vessels.display_in_summary_lists,
	valid_vessels.include_in_generated_instructions,
	valid_vessels.capacity,
	valid_vessels.capacity_unit,
	valid_vessels.width_in_millimeters,
	valid_vessels.length_in_millimeters,
	valid_vessels.height_in_millimeters,
	valid_vessels.shape,
	valid_vessels.last_indexed_at,
	valid_vessels.created_at,
	valid_vessels.last_updated_at,
	valid_vessels.archived_at,
	(
		SELECT COUNT(valid_vessels.id)
		FROM valid_vessels
		WHERE valid_vessels.archived_at IS NULL
			AND valid_vessels.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
			AND valid_vessels.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
			AND (
				valid_vessels.last_updated_at IS NULL
				OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - '999 years'::INTERVAL))
			)
			AND (
				valid_vessels.last_updated_at IS NULL
				OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + '999 years'::INTERVAL))
			)
	) AS filtered_count,
	(
		SELECT COUNT(valid_vessels.id)
		FROM valid_vessels
		WHERE valid_vessels.archived_at IS NULL
	) AS total_count
FROM valid_vessels
WHERE
	valid_vessels.archived_at IS NULL
	AND valid_vessels.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
	AND valid_vessels.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
	AND (
		valid_vessels.last_updated_at IS NULL
		OR valid_vessels.last_updated_at > COALESCE($4, (SELECT NOW() - '999 years'::INTERVAL))
	)
	AND (
		valid_vessels.last_updated_at IS NULL
		OR valid_vessels.last_updated_at < COALESCE($3, (SELECT NOW() + '999 years'::INTERVAL))
	)
GROUP BY valid_vessels.id
ORDER BY valid_vessels.id
LIMIT $6
OFFSET $5
`

type GetValidVesselsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidVesselsRow struct {
	CreatedAt                      time.Time
	ArchivedAt                     sql.NullTime
	LastUpdatedAt                  sql.NullTime
	LastIndexedAt                  sql.NullTime
	Shape                          VesselShape
	Name                           string
	PluralName                     string
	Description                    string
	IconPath                       string
	Slug                           string
	Capacity                       string
	ID                             string
	CapacityUnit                   sql.NullString
	HeightInMillimeters            sql.NullString
	LengthInMillimeters            sql.NullString
	WidthInMillimeters             sql.NullString
	FilteredCount                  int64
	TotalCount                     int64
	IncludeInGeneratedInstructions bool
	DisplayInSummaryLists          bool
	UsableForStorage               bool
}

func (q *Queries) GetValidVessels(ctx context.Context, db DBTX, arg *GetValidVesselsParams) ([]*GetValidVesselsRow, error) {
	rows, err := db.QueryContext(ctx, getValidVessels,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidVesselsRow{}
	for rows.Next() {
		var i GetValidVesselsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.Capacity,
			&i.CapacityUnit,
			&i.WidthInMillimeters,
			&i.LengthInMillimeters,
			&i.HeightInMillimeters,
			&i.Shape,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidVesselsWithIDs = `-- name: GetValidVesselsWithIDs :many

SELECT
	valid_vessels.id,
	valid_vessels.name,
	valid_vessels.plural_name,
	valid_vessels.description,
	valid_vessels.icon_path,
	valid_vessels.usable_for_storage,
	valid_vessels.slug,
	valid_vessels.display_in_summary_lists,
	valid_vessels.include_in_generated_instructions,
	valid_vessels.capacity,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.last_indexed_at as valid_measurement_unit_last_indexed_at,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	valid_vessels.width_in_millimeters,
	valid_vessels.length_in_millimeters,
	valid_vessels.height_in_millimeters,
	valid_vessels.shape,
	valid_vessels.last_indexed_at,
	valid_vessels.created_at,
	valid_vessels.last_updated_at,
	valid_vessels.archived_at
FROM valid_vessels
	JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	AND valid_vessels.id = ANY($1::text[])
`

type GetValidVesselsWithIDsRow struct {
	CreatedAt                         time.Time
	ValidMeasurementUnitCreatedAt     time.Time
	ValidMeasurementUnitArchivedAt    sql.NullTime
	ValidMeasurementUnitLastUpdatedAt sql.NullTime
	ValidMeasurementUnitLastIndexedAt sql.NullTime
	ArchivedAt                        sql.NullTime
	LastIndexedAt                     sql.NullTime
	LastUpdatedAt                     sql.NullTime
	ValidMeasurementUnitDescription   string
	Description                       string
	ValidMeasurementUnitID            string
	ValidMeasurementUnitName          string
	Name                              string
	PluralName                        string
	ValidMeasurementUnitIconPath      string
	ID                                string
	Slug                              string
	Shape                             VesselShape
	ValidMeasurementUnitSlug          string
	ValidMeasurementUnitPluralName    string
	IconPath                          string
	Capacity                          string
	HeightInMillimeters               sql.NullString
	WidthInMillimeters                sql.NullString
	LengthInMillimeters               sql.NullString
	ValidMeasurementUnitVolumetric    sql.NullBool
	IncludeInGeneratedInstructions    bool
	ValidMeasurementUnitImperial      bool
	ValidMeasurementUnitMetric        bool
	ValidMeasurementUnitUniversal     bool
	DisplayInSummaryLists             bool
	UsableForStorage                  bool
}

func (q *Queries) GetValidVesselsWithIDs(ctx context.Context, db DBTX, ids []string) ([]*GetValidVesselsWithIDsRow, error) {
	rows, err := db.QueryContext(ctx, getValidVesselsWithIDs, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidVesselsWithIDsRow{}
	for rows.Next() {
		var i GetValidVesselsWithIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.Capacity,
			&i.ValidMeasurementUnitID,
			&i.ValidMeasurementUnitName,
			&i.ValidMeasurementUnitDescription,
			&i.ValidMeasurementUnitVolumetric,
			&i.ValidMeasurementUnitIconPath,
			&i.ValidMeasurementUnitUniversal,
			&i.ValidMeasurementUnitMetric,
			&i.ValidMeasurementUnitImperial,
			&i.ValidMeasurementUnitSlug,
			&i.ValidMeasurementUnitPluralName,
			&i.ValidMeasurementUnitLastIndexedAt,
			&i.ValidMeasurementUnitCreatedAt,
			&i.ValidMeasurementUnitLastUpdatedAt,
			&i.ValidMeasurementUnitArchivedAt,
			&i.WidthInMillimeters,
			&i.LengthInMillimeters,
			&i.HeightInMillimeters,
			&i.Shape,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchForValidVessels = `-- name: SearchForValidVessels :many

SELECT
	valid_vessels.id,
	valid_vessels.name,
	valid_vessels.plural_name,
	valid_vessels.description,
	valid_vessels.icon_path,
	valid_vessels.usable_for_storage,
	valid_vessels.slug,
	valid_vessels.display_in_summary_lists,
	valid_vessels.include_in_generated_instructions,
	valid_vessels.capacity,
	valid_vessels.capacity_unit,
	valid_vessels.width_in_millimeters,
	valid_vessels.length_in_millimeters,
	valid_vessels.height_in_millimeters,
	valid_vessels.shape,
	valid_vessels.last_indexed_at,
	valid_vessels.created_at,
	valid_vessels.last_updated_at,
	valid_vessels.archived_at
FROM valid_vessels
WHERE valid_vessels.name ILIKE '%' || $1::text || '%'
	AND valid_vessels.archived_at IS NULL
LIMIT 50
`

func (q *Queries) SearchForValidVessels(ctx context.Context, db DBTX, nameQuery string) ([]*ValidVessels, error) {
	rows, err := db.QueryContext(ctx, searchForValidVessels, nameQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ValidVessels{}
	for rows.Next() {
		var i ValidVessels
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.Capacity,
			&i.CapacityUnit,
			&i.WidthInMillimeters,
			&i.LengthInMillimeters,
			&i.HeightInMillimeters,
			&i.Shape,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateValidVessel = `-- name: UpdateValidVessel :execrows

UPDATE valid_vessels SET
	name = $1,
	plural_name = $2,
	description = $3,
	icon_path = $4,
	usable_for_storage = $5,
	slug = $6,
	display_in_summary_lists = $7,
	include_in_generated_instructions = $8,
	capacity = $9,
	capacity_unit = $10,
	width_in_millimeters = $11,
	length_in_millimeters = $12,
	height_in_millimeters = $13,
	shape = $14,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $15
`

type UpdateValidVesselParams struct {
	Capacity                       string
	PluralName                     string
	Description                    string
	IconPath                       string
	ID                             string
	Slug                           string
	Shape                          VesselShape
	Name                           string
	CapacityUnit                   sql.NullString
	WidthInMillimeters             sql.NullString
	LengthInMillimeters            sql.NullString
	HeightInMillimeters            sql.NullString
	IncludeInGeneratedInstructions bool
	DisplayInSummaryLists          bool
	UsableForStorage               bool
}

func (q *Queries) UpdateValidVessel(ctx context.Context, db DBTX, arg *UpdateValidVesselParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateValidVessel,
		arg.Name,
		arg.PluralName,
		arg.Description,
		arg.IconPath,
		arg.UsableForStorage,
		arg.Slug,
		arg.DisplayInSummaryLists,
		arg.IncludeInGeneratedInstructions,
		arg.Capacity,
		arg.CapacityUnit,
		arg.WidthInMillimeters,
		arg.LengthInMillimeters,
		arg.HeightInMillimeters,
		arg.Shape,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateValidVesselLastIndexedAt = `-- name: UpdateValidVesselLastIndexedAt :execrows

UPDATE valid_vessels SET last_indexed_at = NOW() WHERE id = $1 AND archived_at IS NULL
`

func (q *Queries) UpdateValidVesselLastIndexedAt(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, updateValidVesselLastIndexedAt, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
