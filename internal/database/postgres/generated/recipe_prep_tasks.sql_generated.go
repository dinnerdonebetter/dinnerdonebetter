// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: recipe_prep_tasks.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const archiveRecipePrepTask = `-- name: ArchiveRecipePrepTask :execrows

UPDATE recipe_prep_tasks SET archived_at = NOW() WHERE archived_at IS NULL AND id = $1
`

func (q *Queries) ArchiveRecipePrepTask(ctx context.Context, db DBTX, id string) (int64, error) {
	result, err := db.ExecContext(ctx, archiveRecipePrepTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const checkRecipePrepTaskExistence = `-- name: CheckRecipePrepTaskExistence :one

SELECT EXISTS (
	SELECT recipe_prep_tasks.id
	FROM recipe_prep_tasks
		JOIN recipes ON recipe_prep_tasks.belongs_to_recipe=recipes.id
	WHERE recipe_prep_tasks.archived_at IS NULL
		AND recipe_prep_tasks.belongs_to_recipe = $1
		AND recipe_prep_tasks.id = $2
		AND recipes.archived_at IS NULL
		AND recipes.id = $1
)
`

type CheckRecipePrepTaskExistenceParams struct {
	RecipeID         string
	RecipePrepTaskID string
}

func (q *Queries) CheckRecipePrepTaskExistence(ctx context.Context, db DBTX, arg *CheckRecipePrepTaskExistenceParams) (bool, error) {
	row := db.QueryRowContext(ctx, checkRecipePrepTaskExistence, arg.RecipeID, arg.RecipePrepTaskID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createRecipePrepTask = `-- name: CreateRecipePrepTask :exec

INSERT INTO recipe_prep_tasks (
	id,
	name,
	description,
	notes,
	optional,
	explicit_storage_instructions,
	minimum_time_buffer_before_recipe_in_seconds,
	maximum_time_buffer_before_recipe_in_seconds,
	storage_type,
	minimum_storage_temperature_in_celsius,
	maximum_storage_temperature_in_celsius,
	belongs_to_recipe
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10,
	$11,
	$12
)
`

type CreateRecipePrepTaskParams struct {
	ID                                     string
	Name                                   string
	Description                            string
	Notes                                  string
	ExplicitStorageInstructions            string
	BelongsToRecipe                        string
	StorageType                            NullStorageContainerType
	MinimumStorageTemperatureInCelsius     sql.NullString
	MaximumStorageTemperatureInCelsius     sql.NullString
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32
	MinimumTimeBufferBeforeRecipeInSeconds int32
	Optional                               bool
}

func (q *Queries) CreateRecipePrepTask(ctx context.Context, db DBTX, arg *CreateRecipePrepTaskParams) error {
	_, err := db.ExecContext(ctx, createRecipePrepTask,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Notes,
		arg.Optional,
		arg.ExplicitStorageInstructions,
		arg.MinimumTimeBufferBeforeRecipeInSeconds,
		arg.MaximumTimeBufferBeforeRecipeInSeconds,
		arg.StorageType,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.BelongsToRecipe,
	)
	return err
}

const getRecipePrepTask = `-- name: GetRecipePrepTask :many

SELECT
	recipe_prep_tasks.id,
	recipe_prep_tasks.name,
	recipe_prep_tasks.description,
	recipe_prep_tasks.notes,
	recipe_prep_tasks.optional,
	recipe_prep_tasks.explicit_storage_instructions,
	recipe_prep_tasks.minimum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.maximum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.storage_type,
	recipe_prep_tasks.minimum_storage_temperature_in_celsius,
	recipe_prep_tasks.maximum_storage_temperature_in_celsius,
	recipe_prep_tasks.created_at,
	recipe_prep_tasks.last_updated_at,
	recipe_prep_tasks.archived_at,
	recipe_prep_tasks.belongs_to_recipe,
	recipe_prep_task_steps.id as task_step_id,
	recipe_prep_task_steps.belongs_to_recipe_step as task_step_belongs_to_recipe_step,
	recipe_prep_task_steps.belongs_to_recipe_prep_task as task_step_belongs_to_recipe_prep_task,
	recipe_prep_task_steps.satisfies_recipe_step as task_step_satisfies_recipe_step
FROM recipe_prep_tasks
	JOIN recipe_prep_task_steps ON recipe_prep_tasks.id=recipe_prep_task_steps.belongs_to_recipe_prep_task
WHERE recipe_prep_tasks.archived_at IS NULL
	AND recipe_prep_tasks.id = $1
`

type GetRecipePrepTaskRow struct {
	CreatedAt                              time.Time
	LastUpdatedAt                          sql.NullTime
	ArchivedAt                             sql.NullTime
	Name                                   string
	Description                            string
	Notes                                  string
	TaskStepBelongsToRecipePrepTask        string
	ExplicitStorageInstructions            string
	TaskStepBelongsToRecipeStep            string
	TaskStepID                             string
	ID                                     string
	BelongsToRecipe                        string
	StorageType                            NullStorageContainerType
	MaximumStorageTemperatureInCelsius     sql.NullString
	MinimumStorageTemperatureInCelsius     sql.NullString
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32
	MinimumTimeBufferBeforeRecipeInSeconds int32
	Optional                               bool
	TaskStepSatisfiesRecipeStep            bool
}

func (q *Queries) GetRecipePrepTask(ctx context.Context, db DBTX, recipePrepTaskID string) ([]*GetRecipePrepTaskRow, error) {
	rows, err := db.QueryContext(ctx, getRecipePrepTask, recipePrepTaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipePrepTaskRow{}
	for rows.Next() {
		var i GetRecipePrepTaskRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Notes,
			&i.Optional,
			&i.ExplicitStorageInstructions,
			&i.MinimumTimeBufferBeforeRecipeInSeconds,
			&i.MaximumTimeBufferBeforeRecipeInSeconds,
			&i.StorageType,
			&i.MinimumStorageTemperatureInCelsius,
			&i.MaximumStorageTemperatureInCelsius,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToRecipe,
			&i.TaskStepID,
			&i.TaskStepBelongsToRecipeStep,
			&i.TaskStepBelongsToRecipePrepTask,
			&i.TaskStepSatisfiesRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllRecipePrepTasksByRecipe = `-- name: ListAllRecipePrepTasksByRecipe :many

SELECT
	recipe_prep_tasks.id,
	recipe_prep_tasks.name,
	recipe_prep_tasks.description,
	recipe_prep_tasks.notes,
	recipe_prep_tasks.optional,
	recipe_prep_tasks.explicit_storage_instructions,
	recipe_prep_tasks.minimum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.maximum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.storage_type,
	recipe_prep_tasks.minimum_storage_temperature_in_celsius,
	recipe_prep_tasks.maximum_storage_temperature_in_celsius,
	recipe_prep_tasks.created_at,
	recipe_prep_tasks.last_updated_at,
	recipe_prep_tasks.archived_at,
	recipe_prep_tasks.belongs_to_recipe,
	recipe_prep_task_steps.id as task_step_id,
	recipe_prep_task_steps.belongs_to_recipe_step as task_step_belongs_to_recipe_step,
	recipe_prep_task_steps.belongs_to_recipe_prep_task as task_step_belongs_to_recipe_prep_task,
	recipe_prep_task_steps.satisfies_recipe_step as task_step_satisfies_recipe_step
FROM recipe_prep_tasks
	JOIN recipe_prep_task_steps ON recipe_prep_task_steps.belongs_to_recipe_prep_task=recipe_prep_tasks.id
	JOIN recipe_steps ON recipe_prep_task_steps.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_prep_tasks.belongs_to_recipe=recipes.id
WHERE recipe_prep_tasks.archived_at IS NULL
	AND recipe_steps.archived_at IS NULL
	AND recipes.archived_at IS NULL
	AND recipes.id = $1
`

type ListAllRecipePrepTasksByRecipeRow struct {
	CreatedAt                              time.Time
	LastUpdatedAt                          sql.NullTime
	ArchivedAt                             sql.NullTime
	Name                                   string
	Description                            string
	Notes                                  string
	TaskStepBelongsToRecipePrepTask        string
	ExplicitStorageInstructions            string
	TaskStepBelongsToRecipeStep            string
	TaskStepID                             string
	ID                                     string
	BelongsToRecipe                        string
	StorageType                            NullStorageContainerType
	MaximumStorageTemperatureInCelsius     sql.NullString
	MinimumStorageTemperatureInCelsius     sql.NullString
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32
	MinimumTimeBufferBeforeRecipeInSeconds int32
	Optional                               bool
	TaskStepSatisfiesRecipeStep            bool
}

func (q *Queries) ListAllRecipePrepTasksByRecipe(ctx context.Context, db DBTX, recipeID string) ([]*ListAllRecipePrepTasksByRecipeRow, error) {
	rows, err := db.QueryContext(ctx, listAllRecipePrepTasksByRecipe, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListAllRecipePrepTasksByRecipeRow{}
	for rows.Next() {
		var i ListAllRecipePrepTasksByRecipeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Notes,
			&i.Optional,
			&i.ExplicitStorageInstructions,
			&i.MinimumTimeBufferBeforeRecipeInSeconds,
			&i.MaximumTimeBufferBeforeRecipeInSeconds,
			&i.StorageType,
			&i.MinimumStorageTemperatureInCelsius,
			&i.MaximumStorageTemperatureInCelsius,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToRecipe,
			&i.TaskStepID,
			&i.TaskStepBelongsToRecipeStep,
			&i.TaskStepBelongsToRecipePrepTask,
			&i.TaskStepSatisfiesRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipePrepTask = `-- name: UpdateRecipePrepTask :execrows

UPDATE recipe_prep_tasks SET
	name = $1,
	description = $2,
	notes = $3,
	optional = $4,
	explicit_storage_instructions = $5,
	minimum_time_buffer_before_recipe_in_seconds = $6,
	maximum_time_buffer_before_recipe_in_seconds = $7,
	storage_type = $8,
	minimum_storage_temperature_in_celsius = $9,
	maximum_storage_temperature_in_celsius = $10,
	belongs_to_recipe = $11,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $12
`

type UpdateRecipePrepTaskParams struct {
	Name                                   string
	Description                            string
	Notes                                  string
	ExplicitStorageInstructions            string
	BelongsToRecipe                        string
	ID                                     string
	StorageType                            NullStorageContainerType
	MinimumStorageTemperatureInCelsius     sql.NullString
	MaximumStorageTemperatureInCelsius     sql.NullString
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32
	MinimumTimeBufferBeforeRecipeInSeconds int32
	Optional                               bool
}

func (q *Queries) UpdateRecipePrepTask(ctx context.Context, db DBTX, arg *UpdateRecipePrepTaskParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateRecipePrepTask,
		arg.Name,
		arg.Description,
		arg.Notes,
		arg.Optional,
		arg.ExplicitStorageInstructions,
		arg.MinimumTimeBufferBeforeRecipeInSeconds,
		arg.MaximumTimeBufferBeforeRecipeInSeconds,
		arg.StorageType,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.BelongsToRecipe,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
