// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: recipe_step_products.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const archiveRecipeStepProduct = `-- name: ArchiveRecipeStepProduct :exec

UPDATE recipe_step_products SET archived_at = NOW() WHERE archived_at IS NULL AND belongs_to_recipe_step = $1 AND id = $2
`

type ArchiveRecipeStepProductParams struct {
	BelongsToRecipeStep string
	ID                  string
}

func (q *Queries) ArchiveRecipeStepProduct(ctx context.Context, db DBTX, arg *ArchiveRecipeStepProductParams) error {
	_, err := db.ExecContext(ctx, archiveRecipeStepProduct, arg.BelongsToRecipeStep, arg.ID)
	return err
}

const checkRecipeStepProductExistence = `-- name: CheckRecipeStepProductExistence :one

SELECT EXISTS ( SELECT recipe_step_products.id FROM recipe_step_products JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id WHERE recipe_step_products.archived_at IS NULL AND recipe_step_products.belongs_to_recipe_step = $1 AND recipe_step_products.id = $2 AND recipe_steps.archived_at IS NULL AND recipe_steps.belongs_to_recipe = $3 AND recipe_steps.id = $1 AND recipes.archived_at IS NULL AND recipes.id = $3 )
`

type CheckRecipeStepProductExistenceParams struct {
	RecipeStepID        string
	RecipeStepProductID string
	RecipeID            string
}

func (q *Queries) CheckRecipeStepProductExistence(ctx context.Context, db DBTX, arg *CheckRecipeStepProductExistenceParams) (bool, error) {
	row := db.QueryRowContext(ctx, checkRecipeStepProductExistence, arg.RecipeStepID, arg.RecipeStepProductID, arg.RecipeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createRecipeStepProduct = `-- name: CreateRecipeStepProduct :exec

INSERT INTO recipe_step_products
(id,"name","type",measurement_unit,minimum_quantity_value,maximum_quantity_value,quantity_notes,compostable,maximum_storage_duration_in_seconds,minimum_storage_temperature_in_celsius,maximum_storage_temperature_in_celsius,storage_instructions,belongs_to_recipe_step,is_liquid,is_waste,"index",contained_in_vessel_index)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17)
`

type CreateRecipeStepProductParams struct {
	QuantityNotes                      string
	Name                               string
	Type                               RecipeStepProductType
	BelongsToRecipeStep                string
	ID                                 string
	StorageInstructions                string
	MinimumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MaximumQuantityValue               sql.NullString
	MeasurementUnit                    sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	Compostable                        bool
	IsLiquid                           bool
	IsWaste                            bool
}

func (q *Queries) CreateRecipeStepProduct(ctx context.Context, db DBTX, arg *CreateRecipeStepProductParams) error {
	_, err := db.ExecContext(ctx, createRecipeStepProduct,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.Compostable,
		arg.MaximumStorageDurationInSeconds,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.StorageInstructions,
		arg.BelongsToRecipeStep,
		arg.IsLiquid,
		arg.IsWaste,
		arg.Index,
		arg.ContainedInVesselIndex,
	)
	return err
}

const getRecipeStepProduct = `-- name: GetRecipeStepProduct :one

SELECT
	recipe_step_products.id,
	recipe_step_products.name,
	recipe_step_products.type,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	recipe_step_products.minimum_quantity_value,
	recipe_step_products.maximum_quantity_value,
	recipe_step_products.quantity_notes,
	recipe_step_products.compostable,
	recipe_step_products.maximum_storage_duration_in_seconds,
	recipe_step_products.minimum_storage_temperature_in_celsius,
	recipe_step_products.maximum_storage_temperature_in_celsius,
	recipe_step_products.storage_instructions,
	recipe_step_products.is_liquid,
	recipe_step_products.is_waste,
    recipe_step_products.index,
    recipe_step_products.contained_in_vessel_index,
	recipe_step_products.created_at,
	recipe_step_products.last_updated_at,
	recipe_step_products.archived_at,
	recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
	JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
	AND recipe_step_products.belongs_to_recipe_step = $1
	AND recipe_step_products.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $1
	AND recipes.archived_at IS NULL
	AND recipes.id = $3
`

type GetRecipeStepProductParams struct {
	RecipeStepID        string
	RecipeStepProductID string
	RecipeID            string
}

type GetRecipeStepProductRow struct {
	CreatedAt                          time.Time
	ValidMeasurementUnitCreatedAt      time.Time
	ArchivedAt                         sql.NullTime
	LastUpdatedAt                      sql.NullTime
	ValidMeasurementUnitArchivedAt     sql.NullTime
	ValidMeasurementUnitLastUpdatedAt  sql.NullTime
	QuantityNotes                      string
	ValidMeasurementUnitID             string
	ID                                 string
	BelongsToRecipeStep                string
	Name                               string
	ValidMeasurementUnitSlug           string
	ValidMeasurementUnitPluralName     string
	ValidMeasurementUnitDescription    string
	ValidMeasurementUnitName           string
	ValidMeasurementUnitIconPath       string
	StorageInstructions                string
	Type                               RecipeStepProductType
	MaximumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MinimumQuantityValue               sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	ValidMeasurementUnitVolumetric     sql.NullBool
	ValidMeasurementUnitUniversal      bool
	IsWaste                            bool
	IsLiquid                           bool
	Compostable                        bool
	ValidMeasurementUnitImperial       bool
	ValidMeasurementUnitMetric         bool
}

func (q *Queries) GetRecipeStepProduct(ctx context.Context, db DBTX, arg *GetRecipeStepProductParams) (*GetRecipeStepProductRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStepProduct, arg.RecipeStepID, arg.RecipeStepProductID, arg.RecipeID)
	var i GetRecipeStepProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.MinimumQuantityValue,
		&i.MaximumQuantityValue,
		&i.QuantityNotes,
		&i.Compostable,
		&i.MaximumStorageDurationInSeconds,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.IsLiquid,
		&i.IsWaste,
		&i.Index,
		&i.ContainedInVesselIndex,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const getRecipeStepProducts = `-- name: GetRecipeStepProducts :many

SELECT
    recipe_step_products.id,
    recipe_step_products.name,
    recipe_step_products.type,
    valid_measurement_units.id as valid_measurement_unit_id,
    valid_measurement_units.name as valid_measurement_unit_name,
    valid_measurement_units.description as valid_measurement_unit_description,
    valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
    valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
    valid_measurement_units.universal as valid_measurement_unit_universal,
    valid_measurement_units.metric as valid_measurement_unit_metric,
    valid_measurement_units.imperial as valid_measurement_unit_imperial,
    valid_measurement_units.slug as valid_measurement_unit_slug,
    valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
    valid_measurement_units.created_at as valid_measurement_unit_created_at,
    valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
    valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
    recipe_step_products.minimum_quantity_value,
    recipe_step_products.maximum_quantity_value,
    recipe_step_products.quantity_notes,
    recipe_step_products.compostable,
    recipe_step_products.maximum_storage_duration_in_seconds,
    recipe_step_products.minimum_storage_temperature_in_celsius,
    recipe_step_products.maximum_storage_temperature_in_celsius,
    recipe_step_products.storage_instructions,
    recipe_step_products.is_liquid,
    recipe_step_products.is_waste,
    recipe_step_products.index,
    recipe_step_products.contained_in_vessel_index,
    recipe_step_products.created_at,
    recipe_step_products.last_updated_at,
    recipe_step_products.archived_at,
    recipe_step_products.belongs_to_recipe_step,
    (
        SELECT
            COUNT(recipe_step_products.id)
        FROM
            recipe_step_products
        WHERE
            recipe_step_products.archived_at IS NULL
            AND recipe_step_products.belongs_to_recipe_step = $1
            AND recipe_step_products.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
            AND recipe_step_products.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
            AND (
                recipe_step_products.last_updated_at IS NULL
                OR recipe_step_products.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
            )
            AND (
                recipe_step_products.last_updated_at IS NULL
                OR recipe_step_products.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
            )
    ) AS filtered_count,
    (
        SELECT
            COUNT(recipe_step_products.id)
        FROM
            recipe_step_products
        WHERE
            recipe_step_products.archived_at IS NULL
            AND recipe_step_products.belongs_to_recipe_step = $1
    ) AS total_count
FROM recipe_step_products
    JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
    JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
    JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
    AND recipe_step_products.belongs_to_recipe_step = $1
    AND recipe_steps.archived_at IS NULL
    AND recipe_steps.id = $1
    AND recipe_steps.belongs_to_recipe = $6
    AND recipes.archived_at IS NULL
    AND recipes.id = $6
    OFFSET $7
    LIMIT $8
`

type GetRecipeStepProductsParams struct {
	RecipeStepID  string
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	RecipeID      string
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetRecipeStepProductsRow struct {
	CreatedAt                          time.Time
	ValidMeasurementUnitCreatedAt      time.Time
	LastUpdatedAt                      sql.NullTime
	ArchivedAt                         sql.NullTime
	ValidMeasurementUnitArchivedAt     sql.NullTime
	ValidMeasurementUnitLastUpdatedAt  sql.NullTime
	ValidMeasurementUnitIconPath       string
	QuantityNotes                      string
	ID                                 string
	Name                               string
	Type                               RecipeStepProductType
	ValidMeasurementUnitSlug           string
	ValidMeasurementUnitPluralName     string
	ValidMeasurementUnitDescription    string
	ValidMeasurementUnitName           string
	ValidMeasurementUnitID             string
	StorageInstructions                string
	BelongsToRecipeStep                string
	MaximumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MinimumQuantityValue               sql.NullString
	FilteredCount                      int64
	TotalCount                         int64
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	ValidMeasurementUnitVolumetric     sql.NullBool
	ValidMeasurementUnitUniversal      bool
	IsWaste                            bool
	IsLiquid                           bool
	Compostable                        bool
	ValidMeasurementUnitImperial       bool
	ValidMeasurementUnitMetric         bool
}

func (q *Queries) GetRecipeStepProducts(ctx context.Context, db DBTX, arg *GetRecipeStepProductsParams) ([]*GetRecipeStepProductsRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeStepProducts,
		arg.RecipeStepID,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.RecipeID,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeStepProductsRow{}
	for rows.Next() {
		var i GetRecipeStepProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ValidMeasurementUnitID,
			&i.ValidMeasurementUnitName,
			&i.ValidMeasurementUnitDescription,
			&i.ValidMeasurementUnitVolumetric,
			&i.ValidMeasurementUnitIconPath,
			&i.ValidMeasurementUnitUniversal,
			&i.ValidMeasurementUnitMetric,
			&i.ValidMeasurementUnitImperial,
			&i.ValidMeasurementUnitSlug,
			&i.ValidMeasurementUnitPluralName,
			&i.ValidMeasurementUnitCreatedAt,
			&i.ValidMeasurementUnitLastUpdatedAt,
			&i.ValidMeasurementUnitArchivedAt,
			&i.MinimumQuantityValue,
			&i.MaximumQuantityValue,
			&i.QuantityNotes,
			&i.Compostable,
			&i.MaximumStorageDurationInSeconds,
			&i.MinimumStorageTemperatureInCelsius,
			&i.MaximumStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.IsLiquid,
			&i.IsWaste,
			&i.Index,
			&i.ContainedInVesselIndex,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToRecipeStep,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeStepProductsForRecipe = `-- name: GetRecipeStepProductsForRecipe :many

SELECT
    recipe_step_products.id,
    recipe_step_products.name,
    recipe_step_products.type,
    valid_measurement_units.id as valid_measurement_unit_id,
    valid_measurement_units.name as valid_measurement_unit_name,
    valid_measurement_units.description as valid_measurement_unit_description,
    valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
    valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
    valid_measurement_units.universal as valid_measurement_unit_universal,
    valid_measurement_units.metric as valid_measurement_unit_metric,
    valid_measurement_units.imperial as valid_measurement_unit_imperial,
    valid_measurement_units.slug as valid_measurement_unit_slug,
    valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
    valid_measurement_units.created_at as valid_measurement_unit_created_at,
    valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
    valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
    recipe_step_products.minimum_quantity_value,
    recipe_step_products.maximum_quantity_value,
    recipe_step_products.quantity_notes,
    recipe_step_products.compostable,
    recipe_step_products.maximum_storage_duration_in_seconds,
    recipe_step_products.minimum_storage_temperature_in_celsius,
    recipe_step_products.maximum_storage_temperature_in_celsius,
    recipe_step_products.storage_instructions,
    recipe_step_products.is_liquid,
    recipe_step_products.is_waste,
    recipe_step_products.index,
    recipe_step_products.contained_in_vessel_index,
    recipe_step_products.created_at,
    recipe_step_products.last_updated_at,
    recipe_step_products.archived_at,
    recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
    JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
    JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
    JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
    AND recipe_steps.archived_at IS NULL
    AND recipe_steps.belongs_to_recipe = $1
    AND recipes.archived_at IS NULL
    AND recipes.id = $1
`

type GetRecipeStepProductsForRecipeRow struct {
	CreatedAt                          time.Time
	ValidMeasurementUnitCreatedAt      time.Time
	ArchivedAt                         sql.NullTime
	LastUpdatedAt                      sql.NullTime
	ValidMeasurementUnitArchivedAt     sql.NullTime
	ValidMeasurementUnitLastUpdatedAt  sql.NullTime
	QuantityNotes                      string
	ValidMeasurementUnitID             string
	ID                                 string
	BelongsToRecipeStep                string
	Name                               string
	ValidMeasurementUnitSlug           string
	ValidMeasurementUnitPluralName     string
	ValidMeasurementUnitDescription    string
	ValidMeasurementUnitName           string
	ValidMeasurementUnitIconPath       string
	StorageInstructions                string
	Type                               RecipeStepProductType
	MaximumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MinimumQuantityValue               sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	ValidMeasurementUnitVolumetric     sql.NullBool
	ValidMeasurementUnitUniversal      bool
	IsWaste                            bool
	IsLiquid                           bool
	Compostable                        bool
	ValidMeasurementUnitImperial       bool
	ValidMeasurementUnitMetric         bool
}

func (q *Queries) GetRecipeStepProductsForRecipe(ctx context.Context, db DBTX, belongsToRecipe string) ([]*GetRecipeStepProductsForRecipeRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeStepProductsForRecipe, belongsToRecipe)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeStepProductsForRecipeRow{}
	for rows.Next() {
		var i GetRecipeStepProductsForRecipeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ValidMeasurementUnitID,
			&i.ValidMeasurementUnitName,
			&i.ValidMeasurementUnitDescription,
			&i.ValidMeasurementUnitVolumetric,
			&i.ValidMeasurementUnitIconPath,
			&i.ValidMeasurementUnitUniversal,
			&i.ValidMeasurementUnitMetric,
			&i.ValidMeasurementUnitImperial,
			&i.ValidMeasurementUnitSlug,
			&i.ValidMeasurementUnitPluralName,
			&i.ValidMeasurementUnitCreatedAt,
			&i.ValidMeasurementUnitLastUpdatedAt,
			&i.ValidMeasurementUnitArchivedAt,
			&i.MinimumQuantityValue,
			&i.MaximumQuantityValue,
			&i.QuantityNotes,
			&i.Compostable,
			&i.MaximumStorageDurationInSeconds,
			&i.MinimumStorageTemperatureInCelsius,
			&i.MaximumStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.IsLiquid,
			&i.IsWaste,
			&i.Index,
			&i.ContainedInVesselIndex,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipeStepProduct = `-- name: UpdateRecipeStepProduct :exec

UPDATE recipe_step_products
SET
	"name" = $1,
	"type" = $2,
	measurement_unit = $3,
	minimum_quantity_value = $4,
	maximum_quantity_value = $5,
	quantity_notes = $6,
	compostable = $7,
	maximum_storage_duration_in_seconds = $8,
	minimum_storage_temperature_in_celsius = $9,
	maximum_storage_temperature_in_celsius = $10,
	storage_instructions = $11,
	is_liquid = $12,
	is_waste = $13,
    "index" = $14,
    contained_in_vessel_index = $15,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_recipe_step = $16
	AND id = $17
`

type UpdateRecipeStepProductParams struct {
	Name                               string
	Type                               RecipeStepProductType
	ID                                 string
	BelongsToRecipeStep                string
	StorageInstructions                string
	QuantityNotes                      string
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MaximumQuantityValue               sql.NullString
	MinimumQuantityValue               sql.NullString
	MeasurementUnit                    sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	Compostable                        bool
	IsLiquid                           bool
	IsWaste                            bool
}

func (q *Queries) UpdateRecipeStepProduct(ctx context.Context, db DBTX, arg *UpdateRecipeStepProductParams) error {
	_, err := db.ExecContext(ctx, updateRecipeStepProduct,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.Compostable,
		arg.MaximumStorageDurationInSeconds,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.StorageInstructions,
		arg.IsLiquid,
		arg.IsWaste,
		arg.Index,
		arg.ContainedInVesselIndex,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	return err
}
