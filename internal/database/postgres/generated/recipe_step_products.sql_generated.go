// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: recipe_step_products.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const archiveRecipeStepProduct = `-- name: ArchiveRecipeStepProduct :execrows

UPDATE recipe_step_products SET archived_at = NOW() WHERE archived_at IS NULL AND belongs_to_recipe_step = $1 AND id = $2
`

type ArchiveRecipeStepProductParams struct {
	BelongsToRecipeStep string
	ID                  string
}

func (q *Queries) ArchiveRecipeStepProduct(ctx context.Context, db DBTX, arg *ArchiveRecipeStepProductParams) (int64, error) {
	result, err := db.ExecContext(ctx, archiveRecipeStepProduct, arg.BelongsToRecipeStep, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const checkRecipeStepProductExistence = `-- name: CheckRecipeStepProductExistence :one

SELECT EXISTS (
	SELECT recipe_step_products.id
	FROM recipe_step_products
		JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
		JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	WHERE recipe_step_products.archived_at IS NULL
		AND recipe_step_products.belongs_to_recipe_step = $1
		AND recipe_step_products.id = $2
		AND recipe_steps.archived_at IS NULL
		AND recipe_steps.belongs_to_recipe = $3
		AND recipe_steps.id = $1
		AND recipes.archived_at IS NULL
		AND recipes.id = $3
)
`

type CheckRecipeStepProductExistenceParams struct {
	RecipeStepID        string
	RecipeStepProductID string
	RecipeID            string
}

func (q *Queries) CheckRecipeStepProductExistence(ctx context.Context, db DBTX, arg *CheckRecipeStepProductExistenceParams) (bool, error) {
	row := db.QueryRowContext(ctx, checkRecipeStepProductExistence, arg.RecipeStepID, arg.RecipeStepProductID, arg.RecipeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createRecipeStepProduct = `-- name: CreateRecipeStepProduct :exec

INSERT INTO recipe_step_products (
	id,
	name,
	type,
	measurement_unit,
	minimum_quantity_value,
	maximum_quantity_value,
	quantity_notes,
	compostable,
	maximum_storage_duration_in_seconds,
	minimum_storage_temperature_in_celsius,
	maximum_storage_temperature_in_celsius,
	storage_instructions,
	is_liquid,
	is_waste,
	index,
	contained_in_vessel_index,
	belongs_to_recipe_step
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10,
	$11,
	$12,
	$13,
	$14,
	$15,
	$16,
	$17
)
`

type CreateRecipeStepProductParams struct {
	StorageInstructions                string
	Name                               string
	Type                               RecipeStepProductType
	QuantityNotes                      string
	BelongsToRecipeStep                string
	ID                                 string
	MeasurementUnit                    sql.NullString
	MinimumQuantityValue               sql.NullString
	MaximumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	IsLiquid                           bool
	IsWaste                            bool
	Compostable                        bool
}

func (q *Queries) CreateRecipeStepProduct(ctx context.Context, db DBTX, arg *CreateRecipeStepProductParams) error {
	_, err := db.ExecContext(ctx, createRecipeStepProduct,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.Compostable,
		arg.MaximumStorageDurationInSeconds,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.StorageInstructions,
		arg.IsLiquid,
		arg.IsWaste,
		arg.Index,
		arg.ContainedInVesselIndex,
		arg.BelongsToRecipeStep,
	)
	return err
}

const getRecipeStepProduct = `-- name: GetRecipeStepProduct :one

SELECT
	recipe_step_products.id,
	recipe_step_products.name,
	recipe_step_products.type,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.last_indexed_at as valid_measurement_unit_last_indexed_at,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	recipe_step_products.minimum_quantity_value,
	recipe_step_products.maximum_quantity_value,
	recipe_step_products.quantity_notes,
	recipe_step_products.compostable,
	recipe_step_products.maximum_storage_duration_in_seconds,
	recipe_step_products.minimum_storage_temperature_in_celsius,
	recipe_step_products.maximum_storage_temperature_in_celsius,
	recipe_step_products.storage_instructions,
	recipe_step_products.is_liquid,
	recipe_step_products.is_waste,
	recipe_step_products.index,
	recipe_step_products.contained_in_vessel_index,
	recipe_step_products.created_at,
	recipe_step_products.last_updated_at,
	recipe_step_products.archived_at,
	recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
	JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	LEFT JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
	AND recipe_step_products.belongs_to_recipe_step = $1
	AND recipe_step_products.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $1
	AND recipes.archived_at IS NULL
	AND recipes.id = $3
`

type GetRecipeStepProductParams struct {
	RecipeStepID        string
	RecipeStepProductID string
	RecipeID            string
}

type GetRecipeStepProductRow struct {
	CreatedAt                          time.Time
	ValidMeasurementUnitLastIndexedAt  sql.NullTime
	ArchivedAt                         sql.NullTime
	LastUpdatedAt                      sql.NullTime
	ValidMeasurementUnitArchivedAt     sql.NullTime
	ValidMeasurementUnitLastUpdatedAt  sql.NullTime
	ValidMeasurementUnitCreatedAt      sql.NullTime
	StorageInstructions                string
	Type                               RecipeStepProductType
	Name                               string
	BelongsToRecipeStep                string
	ID                                 string
	QuantityNotes                      string
	MaximumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	ValidMeasurementUnitDescription    sql.NullString
	ValidMeasurementUnitName           sql.NullString
	MinimumQuantityValue               sql.NullString
	ValidMeasurementUnitIconPath       sql.NullString
	ValidMeasurementUnitPluralName     sql.NullString
	ValidMeasurementUnitID             sql.NullString
	ValidMeasurementUnitSlug           sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	ValidMeasurementUnitVolumetric     sql.NullBool
	ValidMeasurementUnitImperial       sql.NullBool
	ValidMeasurementUnitMetric         sql.NullBool
	ValidMeasurementUnitUniversal      sql.NullBool
	Compostable                        bool
	IsWaste                            bool
	IsLiquid                           bool
}

func (q *Queries) GetRecipeStepProduct(ctx context.Context, db DBTX, arg *GetRecipeStepProductParams) (*GetRecipeStepProductRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStepProduct, arg.RecipeStepID, arg.RecipeStepProductID, arg.RecipeID)
	var i GetRecipeStepProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitLastIndexedAt,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.MinimumQuantityValue,
		&i.MaximumQuantityValue,
		&i.QuantityNotes,
		&i.Compostable,
		&i.MaximumStorageDurationInSeconds,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.IsLiquid,
		&i.IsWaste,
		&i.Index,
		&i.ContainedInVesselIndex,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const getRecipeStepProducts = `-- name: GetRecipeStepProducts :many

SELECT
	recipe_step_products.id,
	recipe_step_products.name,
	recipe_step_products.type,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.last_indexed_at as valid_measurement_unit_last_indexed_at,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	recipe_step_products.minimum_quantity_value,
	recipe_step_products.maximum_quantity_value,
	recipe_step_products.quantity_notes,
	recipe_step_products.compostable,
	recipe_step_products.maximum_storage_duration_in_seconds,
	recipe_step_products.minimum_storage_temperature_in_celsius,
	recipe_step_products.maximum_storage_temperature_in_celsius,
	recipe_step_products.storage_instructions,
	recipe_step_products.is_liquid,
	recipe_step_products.is_waste,
	recipe_step_products.index,
	recipe_step_products.contained_in_vessel_index,
	recipe_step_products.created_at,
	recipe_step_products.last_updated_at,
	recipe_step_products.archived_at,
	recipe_step_products.belongs_to_recipe_step,
	(
		SELECT COUNT(recipe_step_products.id)
		FROM recipe_step_products
		WHERE
			recipe_step_products.archived_at IS NULL
			AND recipe_step_products.belongs_to_recipe_step = $1
			AND recipe_step_products.created_at > COALESCE($2, (SELECT NOW() - '999 years'::INTERVAL))
			AND recipe_step_products.created_at < COALESCE($3, (SELECT NOW() + '999 years'::INTERVAL))
			AND (
				recipe_step_products.last_updated_at IS NULL
				OR recipe_step_products.last_updated_at > COALESCE($4, (SELECT NOW() - '999 years'::INTERVAL))
			)
			AND (
				recipe_step_products.last_updated_at IS NULL
				OR recipe_step_products.last_updated_at < COALESCE($5, (SELECT NOW() + '999 years'::INTERVAL))
			)
	) AS filtered_count,
	(
		SELECT COUNT(recipe_step_products.id)
		FROM recipe_step_products
		WHERE recipe_step_products.archived_at IS NULL
			AND recipe_step_products.belongs_to_recipe_step = $1
	) AS total_count
FROM recipe_step_products
	JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	LEFT JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
	AND recipe_step_products.belongs_to_recipe_step = $1
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.id = $1
	AND recipe_steps.belongs_to_recipe = $6
	AND recipes.archived_at IS NULL
	AND recipes.id = $6
	AND recipe_step_products.created_at > COALESCE($2, (SELECT NOW() - '999 years'::INTERVAL))
	AND recipe_step_products.created_at < COALESCE($3, (SELECT NOW() + '999 years'::INTERVAL))
	AND (
		recipe_step_products.last_updated_at IS NULL
		OR recipe_step_products.last_updated_at > COALESCE($4, (SELECT NOW() - '999 years'::INTERVAL))
	)
	AND (
		recipe_step_products.last_updated_at IS NULL
		OR recipe_step_products.last_updated_at < COALESCE($5, (SELECT NOW() + '999 years'::INTERVAL))
	)
LIMIT $8
OFFSET $7
`

type GetRecipeStepProductsParams struct {
	RecipeStepID  string
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	RecipeID      string
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetRecipeStepProductsRow struct {
	CreatedAt                          time.Time
	ValidMeasurementUnitLastIndexedAt  sql.NullTime
	ArchivedAt                         sql.NullTime
	LastUpdatedAt                      sql.NullTime
	ValidMeasurementUnitArchivedAt     sql.NullTime
	ValidMeasurementUnitLastUpdatedAt  sql.NullTime
	ValidMeasurementUnitCreatedAt      sql.NullTime
	StorageInstructions                string
	BelongsToRecipeStep                string
	Name                               string
	Type                               RecipeStepProductType
	ID                                 string
	QuantityNotes                      string
	MaximumQuantityValue               sql.NullString
	ValidMeasurementUnitID             sql.NullString
	ValidMeasurementUnitDescription    sql.NullString
	ValidMeasurementUnitName           sql.NullString
	MinimumQuantityValue               sql.NullString
	ValidMeasurementUnitSlug           sql.NullString
	ValidMeasurementUnitPluralName     sql.NullString
	ValidMeasurementUnitIconPath       sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	TotalCount                         int64
	FilteredCount                      int64
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	ValidMeasurementUnitVolumetric     sql.NullBool
	ValidMeasurementUnitUniversal      sql.NullBool
	ValidMeasurementUnitImperial       sql.NullBool
	ValidMeasurementUnitMetric         sql.NullBool
	Compostable                        bool
	IsWaste                            bool
	IsLiquid                           bool
}

func (q *Queries) GetRecipeStepProducts(ctx context.Context, db DBTX, arg *GetRecipeStepProductsParams) ([]*GetRecipeStepProductsRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeStepProducts,
		arg.RecipeStepID,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.RecipeID,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeStepProductsRow{}
	for rows.Next() {
		var i GetRecipeStepProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ValidMeasurementUnitID,
			&i.ValidMeasurementUnitName,
			&i.ValidMeasurementUnitDescription,
			&i.ValidMeasurementUnitVolumetric,
			&i.ValidMeasurementUnitIconPath,
			&i.ValidMeasurementUnitUniversal,
			&i.ValidMeasurementUnitMetric,
			&i.ValidMeasurementUnitImperial,
			&i.ValidMeasurementUnitSlug,
			&i.ValidMeasurementUnitPluralName,
			&i.ValidMeasurementUnitLastIndexedAt,
			&i.ValidMeasurementUnitCreatedAt,
			&i.ValidMeasurementUnitLastUpdatedAt,
			&i.ValidMeasurementUnitArchivedAt,
			&i.MinimumQuantityValue,
			&i.MaximumQuantityValue,
			&i.QuantityNotes,
			&i.Compostable,
			&i.MaximumStorageDurationInSeconds,
			&i.MinimumStorageTemperatureInCelsius,
			&i.MaximumStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.IsLiquid,
			&i.IsWaste,
			&i.Index,
			&i.ContainedInVesselIndex,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToRecipeStep,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeStepProductsForRecipe = `-- name: GetRecipeStepProductsForRecipe :many

SELECT
	recipe_step_products.id,
	recipe_step_products.name,
	recipe_step_products.type,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.last_indexed_at as valid_measurement_unit_last_indexed_at,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	recipe_step_products.minimum_quantity_value,
	recipe_step_products.maximum_quantity_value,
	recipe_step_products.quantity_notes,
	recipe_step_products.compostable,
	recipe_step_products.maximum_storage_duration_in_seconds,
	recipe_step_products.minimum_storage_temperature_in_celsius,
	recipe_step_products.maximum_storage_temperature_in_celsius,
	recipe_step_products.storage_instructions,
	recipe_step_products.is_liquid,
	recipe_step_products.is_waste,
	recipe_step_products.index,
	recipe_step_products.contained_in_vessel_index,
	recipe_step_products.created_at,
	recipe_step_products.last_updated_at,
	recipe_step_products.archived_at,
	recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
	JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	LEFT JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $1
	AND recipes.archived_at IS NULL
	AND recipes.id = $1
`

type GetRecipeStepProductsForRecipeRow struct {
	CreatedAt                          time.Time
	ValidMeasurementUnitLastIndexedAt  sql.NullTime
	ArchivedAt                         sql.NullTime
	LastUpdatedAt                      sql.NullTime
	ValidMeasurementUnitArchivedAt     sql.NullTime
	ValidMeasurementUnitLastUpdatedAt  sql.NullTime
	ValidMeasurementUnitCreatedAt      sql.NullTime
	StorageInstructions                string
	Type                               RecipeStepProductType
	Name                               string
	BelongsToRecipeStep                string
	ID                                 string
	QuantityNotes                      string
	MaximumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	ValidMeasurementUnitDescription    sql.NullString
	ValidMeasurementUnitName           sql.NullString
	MinimumQuantityValue               sql.NullString
	ValidMeasurementUnitIconPath       sql.NullString
	ValidMeasurementUnitPluralName     sql.NullString
	ValidMeasurementUnitID             sql.NullString
	ValidMeasurementUnitSlug           sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	ValidMeasurementUnitVolumetric     sql.NullBool
	ValidMeasurementUnitImperial       sql.NullBool
	ValidMeasurementUnitMetric         sql.NullBool
	ValidMeasurementUnitUniversal      sql.NullBool
	Compostable                        bool
	IsWaste                            bool
	IsLiquid                           bool
}

func (q *Queries) GetRecipeStepProductsForRecipe(ctx context.Context, db DBTX, recipeID string) ([]*GetRecipeStepProductsForRecipeRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeStepProductsForRecipe, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeStepProductsForRecipeRow{}
	for rows.Next() {
		var i GetRecipeStepProductsForRecipeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ValidMeasurementUnitID,
			&i.ValidMeasurementUnitName,
			&i.ValidMeasurementUnitDescription,
			&i.ValidMeasurementUnitVolumetric,
			&i.ValidMeasurementUnitIconPath,
			&i.ValidMeasurementUnitUniversal,
			&i.ValidMeasurementUnitMetric,
			&i.ValidMeasurementUnitImperial,
			&i.ValidMeasurementUnitSlug,
			&i.ValidMeasurementUnitPluralName,
			&i.ValidMeasurementUnitLastIndexedAt,
			&i.ValidMeasurementUnitCreatedAt,
			&i.ValidMeasurementUnitLastUpdatedAt,
			&i.ValidMeasurementUnitArchivedAt,
			&i.MinimumQuantityValue,
			&i.MaximumQuantityValue,
			&i.QuantityNotes,
			&i.Compostable,
			&i.MaximumStorageDurationInSeconds,
			&i.MinimumStorageTemperatureInCelsius,
			&i.MaximumStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.IsLiquid,
			&i.IsWaste,
			&i.Index,
			&i.ContainedInVesselIndex,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipeStepProduct = `-- name: UpdateRecipeStepProduct :execrows

UPDATE recipe_step_products SET
	name = $1,
	type = $2,
	measurement_unit = $3,
	minimum_quantity_value = $4,
	maximum_quantity_value = $5,
	quantity_notes = $6,
	compostable = $7,
	maximum_storage_duration_in_seconds = $8,
	minimum_storage_temperature_in_celsius = $9,
	maximum_storage_temperature_in_celsius = $10,
	storage_instructions = $11,
	is_liquid = $12,
	is_waste = $13,
	index = $14,
	contained_in_vessel_index = $15,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_recipe_step = $16
	AND id = $17
`

type UpdateRecipeStepProductParams struct {
	Name                               string
	Type                               RecipeStepProductType
	ID                                 string
	BelongsToRecipeStep                string
	StorageInstructions                string
	QuantityNotes                      string
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MaximumQuantityValue               sql.NullString
	MinimumQuantityValue               sql.NullString
	MeasurementUnit                    sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	Compostable                        bool
	IsLiquid                           bool
	IsWaste                            bool
}

func (q *Queries) UpdateRecipeStepProduct(ctx context.Context, db DBTX, arg *UpdateRecipeStepProductParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateRecipeStepProduct,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.Compostable,
		arg.MaximumStorageDurationInSeconds,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.StorageInstructions,
		arg.IsLiquid,
		arg.IsWaste,
		arg.Index,
		arg.ContainedInVesselIndex,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
